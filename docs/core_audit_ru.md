# Технический аудит ядра

Ниже — технический аудит «ядра» (core/pipeline/layers/data/cache/CLI/tests). Фокус: риски функционала, логические дыры, несоответствия, потенциальные блокеры.

## Критичные/блокирующие
- Потеря работоспособности после ошибки: TranslationEngine.translate при исключении ставит state=error и оставляет его навсегда; дальнейшие вызовы бросают (нет восстановления/auto-reset/try-finally для возврата в ready).
- Состояние и конкурентность: translate не поддерживает параллелизм (второй вызов в processing приведет к исключению). Нет очереди/ограничителя/канселяции/таймаутов на запрос.
- LayerAdapter не использует BaseTranslationLayer.processWithMetrics: метрики и валидация слоя обходятся, debug/статистика слоев — номинальные.
- Сильное рассогласование токенизации: PreProcessingLayer поддерживает латиницу/кириллицу/СJK, а DictionaryLayer токенизирует только [A-Za-z]; не-латинские слова не переводятся, конвейер несогласован.
- PhraseTranslationLayer умеет только exact-lookup; N-граммы/фаззимэтч отсутствуют — большинство реальных фраз не обрабатываются.
- JSONL-репозитории: addTranslation/addPhrase перезаписывают весь файл на КАЖДУЮ запись (O(n²) на импорт), без файловых блокировок/атомарности — высокие риски порчи данных и немасштабируемо.
- Потенциальная некомпилируемость: WordOrderLayer использует Iterable.firstOrNull без импорта расширений — выпадет ошибка сборки.
- CLI/пакетирование: в репозитории нет pubspec/entrypoint (translate_engine.dart), docs указывают на команды, которых нет как исполняемый биндинг; сборка/запуск CLI под вопросом.
- Конфигурация EngineConfig фактически не применяется: initialize принимает Map, _applyConfig — заглушка; большинство флагов (TTL, лимиты, логгирование, rate limit, quality) не задействованы.

## Серьезные проблемные зоны
- Состояния pipeline: после успешной обработки состояние остается completed (не idle), наблюдателям трудно трактовать «готовность». Нет явной финализации шага.
- Silence-fail в _initializeDefaultLayers: любые проблемы заглушаются, слои не регистрируются, а перевод молча вернёт originalText с confidence=0.5 — тяжело диагностировать.
- Достоверность грамматики/порядка слов: правила упрощены до прототипа, отдельные regex/replacement выглядят некорректно (пример: verb_to_be_present replacement с «|» вместо реальной подстановки). Высокий риск порчи текста.
- PostProcessingLayer правит пунктуацию/регистр эвристически, может портить тексты для языков с нелатинским письмом, кавычками, NBSP (особенно FR), и насаждать «.» в конце там, где не требуется.
- CacheManager: фактические хиты/промахи не отражают реальность, т.к. репозитории кладут объекты в generic-кэш, минуя Word/PhraseCacheEntry; TTL/eviction не применяются к generic; метрики getCacheInfo в Engine — заглушки.
- Память: in-memory индексы для каждого langPair без выгрузки/ограничений; при множестве пар — рост памяти без контроля.
- Импорт: CSV парсинг на split(delimiter) (без кавычек/эскейпа), нет отчёта о некорректных строках (кроме «первые 10»), нет транзакционной семантики (частичный импорт оставит файл в промежуточном состоянии).
- Хранилище: readAsLinesSync() при загрузке — блокирующее, не потоково; rewriteJsonLines без fsync/atomic rename; нет блокировок — гонки между процессами.
- Безопасность загрузок: DbCommand тянет из GitHub raw без проверки подписи/хэшей; нет retry/backoff; source подменяем; пригодно для прототипа, не для production.
- Тестовая база: часть тестов skip; нет тестов на большие данные/производительность/конкурентный доступ/восстановление после ошибок/атомарность записи.

## Логические несоответствия и дыры
- Семантика TextToken: в DictionaryLayer «normalized» используется для текста перевода, а флаг wasNormalized сравнивает с original — концептуальная путаница между «нормализацией» и «переводом».
- Confidence: Pipeline считает confidence по debugInfo (cacheHits/itemsProcessed), но слои чаще не заполняют эти поля — метрика псевдо-значима. Фолбек 0.5 при «ничего не сделано» — вводящий в заблуждение.
- hasDataAccess всегда true — маскирует проблемы доступа к данным.
- Восстановление после ошибки: нет пути «очистить ошибку» (reset), нет переводов с degrade-модой (например, только словарь) при сбое последующих слоев.
- Путь данных по умолчанию: конкатенация строки 'translation_data' к Directory.current.uri.toFilePath() — зависит от хвостового слеша, риск неверного пути; нет проверки доступности/прав.
- Stream lifecycle: factory TranslationEngine.instance(reset: true) вызывает _dispose() без await — гонки, потенциально незавершенное закрытие стримов перед пересозданием.
- Валидация входа: translate('') возвращает ошибку объектом, но не исключение — неоднородная модель ошибок (где-то исключения, где-то «результат с ошибкой»).
- WordOrder/Grammar применяют упрощённые эвристики ко всему тексту; отсутствие языка-специфичных NLP может вносить артефакты (особенно при смешанных скриптах/эмодзи/символах).
- Репозитории не нормализуют Unicode (NFC/NFD) глобально; сравнения/ключи завязаны на простое .toLowerCase(), возможны «двойники» и промахи на диакритике.
- Нет версионирования формата данных (schema/version) — невозможна безопасная эволюция JSONL.

## Производительность и масштабируемость
- Импорт O(n²) и синхронные операции — главный узкий горлышко.
- Полные индексы в памяти (bySource) без сегментации/шардирования; нет lazy-loading/меммапинга.
- Поиск в словаре — простое contains() по строке, отсутствуют индексы/префиксные структуры; фразовый поиск — только exact (пусто для 90% реальных случаев).
- Кэш на LRU с TTL не интегрирован в горячую дорожку (ключи, типы записей), фактическая отдача — сомнительна.
- Нет бенчмарков/метрик слоев — нельзя управлять бюджетом задержек.

## Надёжность/устойчивость
- Нет file-locks/atomic writes — риск порчи данных при конкурентной записи/сбое.
- Нет retry/backoff на I/O/сети (download/import).
- Нет механизмов graceful degradation (отключить проблемный слой, fallback к словарю/фразам).
- Нет верификации данных при загрузке (schema validation, поля времени, допустимые пары языков).

## API/документация/UX
- Документация обещает CLI и интеграцию, которых в текущем дереве не видно (нет pubspec/entrypoint). Несоответствие приведет к «не запускается».
- EngineConfig — объявлен и экспортируется, но не действует; ожидания пользователей не будут выполнены.
- getCacheInfo/статистика — заглушки; «псевдометрическая» информация вводит в заблуждение при отладке.

## Тестовые пробелы
- Отсутствуют: конкуренция, многопоточность, большие файлы (мб+), поврежденные строки JSONL, атомарность переписей, восстановление после исключений в середине конвейера, корректность для нелатинских языков в DictionaryLayer.
- Бенчмарки отсутствуют; e2e по CLI — отсутствуют.

## Рекомендации (что мешает функционалу прямо сейчас)
- Исправить критичное:
  - В Engine.translate — try/finally и «возврат в ready»; при ошибке — soft-reset (state->ready) или режим degraded; добавить метод reset().
  - Использовать BaseTranslationLayer.processWithMetrics в LayerAdapter, выровнять семантику метрик.
  - DictionaryLayer: заменить ASCII-токенизацию на общую из PreProcessingLayer (использовать уже сохраненные tokens), покрыть кириллицу/СJK.
  - Реализовать хотя бы простейший n-gram в PhraseTranslationLayer (би-/триграммы с окнами).
  - Починить firstOrNull (импорт package:collection) или убрать; проверить все regex/replacement в Grammar/WordOrder (минимум — отключить «ломающие» правила).
  - Репозитории: пакетная запись — накапливать изменения и переписывать файл один раз; делать atomic write (tmp + rename); опционально file lock.
  - Интегрировать CacheManager корректно: ключи, типы entry, TTL, метрики; в Engine.getCacheInfo возвращать реальные metrics.
  - Применить EngineConfig: лимиты кэша, TTL, debug, лог-уровни, maxProcessingTime, и т.д.
- Быстрые фиксы UX/стабильности:
  - Логировать причины незагрузки слоев вместо silent-fail; если нет слоев — вернуть явную ошибку/предупреждение, а не confidence=0.5.
  - Исправить путь данных (надежное соединение path.join/Platform.pathSeparator).
  - Нормализовать Unicode (NFC) на входе в репозитории и при ключах.
- Средний срок:
  - Пересобрать импортеры: нормальный CSV-парсер, отчетность об ошибках, транзакционность (write to temp + swap), батчевый режим.
  - Ввести очередь/ограничитель параллелизма (semaphore) для translate; добавить cancellation token / timeout per request.
  - Вынести языкоспецифичные правила в внешние JSONL со схемой и тестами; сделать версионирование правил/данных.
- Дальше:
  - Бенчмарки и интеграционные тесты на корпусах; профилирование горячих путей; оптимизация индексов (префиксные деревья/хэши).
  - Наблюдаемость: структурированные логи, метрики слоев, трассировка.
  - Пересмотр PostProcessing с учетом языка (NBSP, кавычки, sentence-enders), чтобы не портить текст.
